# services/notify_user.py
import logging
import inspect
import asyncio
import io
from typing import Optional, List, Dict, Any, Iterable
from telegram import Bot, InputMediaPhoto
from telegram.constants import ParseMode
from config import BOT_TOKEN
from services.chart_service import generate_chart

logger = logging.getLogger(__name__)

TELEGRAM_MAX_MSG_LEN = 4096

# Lazily created shared Bot instance (fallback if caller doesn't pass context.bot)
_SHARED_BOT: Optional[Bot] = None


def _is_valid_token(token: Optional[str]) -> bool:
    return bool(token and isinstance(token, str) and token.strip())


def _truncate_message(msg: str) -> str:
    if not isinstance(msg, str):
        msg = str(msg)
    if len(msg) <= TELEGRAM_MAX_MSG_LEN:
        return msg
    return msg[: TELEGRAM_MAX_MSG_LEN - 3] + "..."


def _get_bot(provided_bot: Optional[Bot] = None) -> Bot:
    """
    Return a Bot to use: prefer provided_bot, fallback to a shared Bot created from BOT_TOKEN.
    """
    global _SHARED_BOT
    if provided_bot is not None:
        return provided_bot
    if not _SHARED_BOT:
        if not _is_valid_token(BOT_TOKEN):
            raise RuntimeError("BOT_TOKEN not configured")
        _SHARED_BOT = Bot(token=BOT_TOKEN)
    return _SHARED_BOT


async def _maybe_send(callable_or_method, /, *args, **kwargs):
    """
    Call and await if coroutine; otherwise run in thread. Works for Bot methods or other callables.
    """
    try:
        if inspect.iscoroutinefunction(callable_or_method):
            return await callable_or_method(*args, **kwargs)
        # method might be bound sync function
        result = callable_or_method(*args, **kwargs)
        if inspect.isawaitable(result):
            return await result
        # if result is a regular value, execute it in a thread to avoid blocking the loop
        # (rare case, but safe)
        return await asyncio.to_thread(lambda: result)
    except TypeError:
        # Some library versions implement methods as normal callables that may raise TypeError if called wrongly;
        # fallback to running in thread
        return await asyncio.to_thread(lambda: callable_or_method(*args, **kwargs))


async def notify_user(user_id: int, message: str, parse_mode: Optional[str] = None, bot: Optional[Bot] = None) -> bool:
    """
    Send a plain text notification to a Telegram user.
    """
    try:
        if not _is_valid_token(BOT_TOKEN) and bot is None:
            logger.error("BOT_TOKEN is not configured or invalid and no bot provided.")
            return False

        bot_to_use = _get_bot(bot)
        text = _truncate_message(message)

        send_fn = getattr(bot_to_use, "send_message")
        await _maybe_send(send_fn, chat_id=user_id, text=text, parse_mode=parse_mode)
        logger.info("Successfully notified user %s", user_id)
        return True
    except Exception as e:
        logger.exception("Failed to notify user %s: %s", user_id, e)
        return False


async def _send_media_group_nonblocking(bot: Bot, chat_id: int, media: List[InputMediaPhoto]):
    """
    Helper to call send_media_group safely (await or run in thread).
    """
    send_fn = getattr(bot, "send_media_group")
    # some versions of python-telegram-bot expect files in open file objects, but InputMediaPhoto with BytesIO works.
    return await _maybe_send(send_fn, chat_id=chat_id, media=media)


def _is_buffer_like(obj) -> bool:
    return hasattr(obj, "read") and hasattr(obj, "seek")


async def notify_user_with_charts(
    user_id: int,
    message: str,
    chart_data_list: Optional[List[Dict[str, Any]]] = None,
    bot: Optional[Bot] = None
) -> bool:
    """
    Send a message and optional chart images to a Telegram user.

    chart_data_list:
      - If elements contain a 'buffer' or are buffer-like, they will be sent as images.
      - If elements are dicts with {'symbol': 'BTCUSD', 'timeframe': 15}, charts will be generated by services.chart_service.generate_chart.
      - If elements contain {'error': '...'} an error text will be sent.
    """
    try:
        if not _is_valid_token(BOT_TOKEN) and bot is None:
            logger.error("BOT_TOKEN is not configured or invalid and no bot provided.")
            return False

        bot_to_use = _get_bot(bot)
        text = _truncate_message(message)

        # 1) send main message first (with formatting)
        try:
            send_msg_fn = getattr(bot_to_use, "send_message")
            await _maybe_send(send_msg_fn, chat_id=user_id, text=text, parse_mode=ParseMode.MARKDOWN)
        except Exception:
            # don't abort on message failure; continue to attempt charts
            logger.exception("Failed to send main alert message to user %s", user_id)

        if not chart_data_list:
            logger.info("No chart data to send for user %s", user_id)
            return True

        # Decide how to obtain buffers:
        # - If entries already contain buffers / buffer-like objects -> use them
        # - Otherwise, if entries contain symbol/timeframe -> group by timeframe and call generate_chart
        buffers_to_send: List[io.BytesIO] = []
        errors_to_send: List[str] = []

        # First pass: extract any pre-generated buffers and collect symbol/timeframe requests
        symbol_groups: Dict[int, List[str]] = {}  # timeframe -> list of symbols
        for entry in chart_data_list:
            if entry is None:
                continue
            # If entry appears to be a raw buffer
            if _is_buffer_like(entry):
                try:
                    entry.seek(0)
                except Exception:
                    pass
                buffers_to_send.append(entry)
                continue

            if isinstance(entry, dict):
                if "buffer" in entry and _is_buffer_like(entry["buffer"]):
                    buf = entry["buffer"]
                    try:
                        buf.seek(0)
                    except Exception:
                        pass
                    buffers_to_send.append(buf)
                    continue
                if "error" in entry:
                    errors_to_send.append(str(entry["error"]))
                    continue
                # symbol/timeframe case
                sym = entry.get("symbol")
                tf = entry.get("timeframe")
                if sym and tf:
                    try:
                        tf_key = int(tf)
                    except Exception:
                        tf_key = int(tf) if isinstance(tf, int) else 0
                    symbol_groups.setdefault(tf_key, []).append(sym)
                    continue
                # fallback: text representation
                errors_to_send.append(str(entry))
                continue

            # anything else -> stringify and add as an error message
            errors_to_send.append(str(entry))

        # Generate charts for grouped timeframes
        for tf, syms in symbol_groups.items():
            try:
                # call generate_chart(symbols, timeframe) - it returns list[BytesIO]
                # ensure we call async if function is coroutine; chart_service.generate_chart is async in your code
                if inspect.iscoroutinefunction(generate_chart):
                    chart_buffers = await generate_chart(syms, timeframe=tf)
                else:
                    # run synchronous generator in thread
                    chart_buffers = await asyncio.to_thread(generate_chart, syms, tf)

                # append non-empty buffers
                for b in chart_buffers:
                    if _is_buffer_like(b):
                        try:
                            b.seek(0)
                        except Exception:
                            pass
                        buffers_to_send.append(b)
                    else:
                        # if chart generator returns something else, stringify
                        errors_to_send.append(f"Chart generator returned non-buffer for tf={tf}, sym list={syms}")
            except Exception as e:
                logger.exception("Chart generation failed for timeframe %s symbols %s: %s", tf, syms, e)
                errors_to_send.append(f"Chart generation failed for {syms} @ {tf}m: {e}")

        # Send error messages (if any) as plain text so user knows
        for err in errors_to_send:
            try:
                await _maybe_send(getattr(bot_to_use, "send_message"), chat_id=user_id, text=_truncate_message(f"âŒ {err}"))
            except Exception:
                logger.exception("Failed to send chart error message to user %s: %s", user_id, err)

        # If no buffers to send, we're done
        if not buffers_to_send:
            logger.info("No chart buffers to send for user %s", user_id)
            return True

        # Telegram send_media_group limit: max 10 items per request
        MAX_MEDIA = 10
        media_batches: Iterable[List[io.BytesIO]] = (
            [buffers_to_send[i:i + MAX_MEDIA] for i in range(0, len(buffers_to_send), MAX_MEDIA)]
        )

        for batch in media_batches:
            media_items: List[InputMediaPhoto] = []
            for buf in batch:
                # make sure buffer is at start
                try:
                    buf.seek(0)
                except Exception:
                    pass
                # InputMediaPhoto accepts file-like objects
                media_items.append(InputMediaPhoto(media=buf))

            # send as media_group; this will send multiple images in one album
            try:
                await _send_media_group_nonblocking(bot_to_use, chat_id=user_id, media=media_items)
            except Exception:
                # Fallback: send images one-by-one if media_group fails
                logger.exception("send_media_group failed for user %s; falling back to send_photo per image", user_id)
                for buf in batch:
                    try:
                        await _maybe_send(getattr(bot_to_use, "send_photo"), chat_id=user_id, photo=buf)
                    except Exception:
                        logger.exception("Failed to send individual chart photo to user %s", user_id)
                        continue

        logger.info("Successfully notified user %s with %d chart(s)", user_id, len(buffers_to_send))
        return True

    except Exception as e:
        logger.exception("Failed to notify user %s with charts: %s", user_id, e)
        return False


def format_alert_message(message: str) -> str:
    """
    Format alert message for presentation.
    """
    if not isinstance(message, str):
        message = str(message)
    return message


async def send_alert_notification(
    user_id: int,
    alert_message: str,
    chart_data_list: Optional[List[Dict[str, Any]]] = None,
    bot: Optional[Bot] = None
) -> bool:
    """
    High-level API used by the alert service to notify users.
    """
    try:
        if chart_data_list:
            return await notify_user_with_charts(user_id, alert_message, chart_data_list, bot=bot)
        else:
            formatted_message = format_alert_message(alert_message)
            return await notify_user(user_id, formatted_message, ParseMode.MARKDOWN, bot=bot)
    except Exception as e:
        logger.exception("Error sending alert notification to user %s: %s", user_id, e)
        return False
